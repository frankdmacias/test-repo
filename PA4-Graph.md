# PA4: Graphs - Six Degrees of Kevin Bacon

## Due Date: Wednesday 11:59pm, July 28th, 2021

## Overview

- [PA4: Graphs - Six Degrees of Kevin Bacon](#pa4-graphs---six-degrees-of-kevin-bacon)
  - [Overview](#overview)
    - [Motivation of PA](#motivation-of-pa)
    - [Background / Game Overview](#background--game-overview)
  - [Getting Started](#getting-started)
    - [Important Notes about imdb_2019.tsv](#important-notes-about-imdb2019tsv)
  - [Part A: Pathfinder on Unweighted Graph (BFS)](#part-a-pathfinder-on-unweighted-graph-bfs)
    - [1. Design and implement your node and edge classes](#1-design-and-implement-your-node-and-edge-classes)
    - [Write a program called pathfinder (in pathfinder.cpp) to find the shortest path from one actor to another actor through shared movies](#write-a-program-called-pathfinder-in-pathfindercpp-to-find-the-shortest-path-from-one-actor-to-another-actor-through-shared-movies)
  - [Part B: Pathfinder on Weighted Graph (Dijkstra)](#part-b-pathfinder-on-weighted-graph-dijkstra)
    - [1. Complete your pathfinder program by implementing the "weighted edges" version of your program, where the edge weight is the age of the movie](#1-complete-your-pathfinder-program-by-implementing-the-%22weighted-edges%22-version-of-your-program-where-the-edge-weight-is-the-age-of-the-movie)
  - Part C: Complete the PA4 worksheet (on gradescope)
  - [Hints and Warning](#hints-and-warning)
    - [Hints](#hints)
    - [Warning](#warning)
  - [Extra Credit : Complete CAPE](#extra-credit--complete-cape)
  - [Submission instructions](#submission-instructions)

### Motivation of PA

The motivation of this assignment is twofold.  Firstly, it gives you the freedom to demonstrate your own unique coding style and class design (this is the reason for **barely any starter code**).  The second goal is to show a fundamental application of graph traversal that is common in data science.

### Background / Game Overview

"Six Degrees of Kevin Bacon" is a parlor game based on the "six degrees of separation" concept, which proposes that any two people on Earth are six or fewer acquaintance-links apart. This idea eventually morphed into a parlor game where movie buffs challenge each other to find the shortest path between some arbitrary actor and Hollywood actor Kevin Bacon. It rests on the assumption that anyone involved in the Hollywood film industry can be linked through their film roles to Bacon in six or fewer steps. The game requires a group of players to try to connect any such individual to Kevin Bacon as quickly and in as few links as possible.  In the first part of the assignment, you will implement the generalized version of the Kevin Bacon game.

## Getting Started

**Files Provided:**

Starter Code:

1. `Makefile` - which you should modify as you add source code and modify the initial dependencies
2. `ActorGraph.hpp/cpp` -   contains starter code that reads in imdb_2019.tsv

Files to test your code:

1. `imdb_2019.tsv` - The database that contains the majority of actors/ actresses found in IMDb. See the notes below for more details.
2. `pathfinder1_graph.tsv` - The database that contains a small set of actors/ actresses found in IMDb.
3. `random_actor_pairs.tsv` - Text file that  contains 100 pair of actors you can use for testing.
4. `test_pairs.tsv` - Text file containing the pairs of actors to find paths/connections(details explained later)
5. `out_paths_unweighted.tsv` - Output file generated by Pathfinder that stores the results from finding the unweighted shortest path between two actors in test_pairs.tsv. The graph is built using the imdb_2019.tsv file.
6. `out_paths_weighted.tsv`  - Output file generated by Pathfinder that stores the results from finding the weighted shortest path between two actors in test_pairs.tsv. The graph is built using the imdb_2019.tsv file.
7. `refpathfinder` - Solution executable that implements Pathfinder. You can find the executable by going to the following directory in your ieng6 account: /home/linux/ieng6/cs100s121/public/pa4_refs

### Important Notes about imdb_2019.tsv

We have provided you a tab-separated file that contains the majority of actors/actresses found in IMDb and the movies they have played in. Specifically, the file looks like this ("TAB" denotes a single tab character):

``` txt
Actor/Actress<TAB>Movie<TAB>Year
Kevin Bacon<TAB>Queens Logic<TAB>1991
Kevin Bacon<TAB>She's Having a Baby<TAB>1988
Kevin Bacon<TAB>Balto<TAB>1995
Kevin Bacon<TAB>Diner<TAB>1982
Kevin Bacon<TAB>Loverboy<TAB>2005
Kevin Bacon<TAB>Rails & Ties<TAB>2007
Kevin Bacon<TAB>Where the Truth Lies<TAB>2005
Kevin Bacon<TAB>Sleepers<TAB>1996
...
```

a) The first column contains the name of the actor/actress, the second column contains the name of a movie they played in, and the last column contains the year the movie was made.

b) Each line defines a single actor→movie relationship in this manner (except for the first line, which is the header). You may assume that actor→movie relationships will be grouped by actor name, but do not assume they will be sorted.

c) Note that multiple movies made in different years can have the same name, so use movie year as well as title when checking if two are the same.

d) Make sure you DO NOT format the names of actors or movies beyond what is given in the tab-separated input file. In other words, each actor's name should be taken exactly as the actor's name appears in the imdb_2019.tsv file. You do not have to (and should not) mess with it. During grading, the actor's name in the test file will match the actor's name in the imdb_2019.tsv file.

**Note: The imdb_2019.tsv file is pretty big, so please do not upload it upon submission.**

## Part A: Pathfinder on Unweighted Graph (BFS)

### 1. Design and implement your node and edge classes

In order to complete the rest of the assignment, you must first design your graph structure and implement the necessary classes. In your graph, each actor/actress will define a single node. Two nodes (i.e., actors) will be connected by an undirected edge if the corresponding actors played in the same movie.  Multiple undirected edges can exist between the same two nodes (which would imply that the two actors played in multiple movies together).

**Implementation Checklist:**

* **Review ActorGraph.cpp:** This contains starter code to read the imdb_2019.tsv file (the code opens a file and parses the actor/movie/year from each line). For the implementations below, you may have to create separate .cpp files for your different classes based on your design.
* **Design/Implement your node objects (actors/actresses):** What information does your node need to contain?
* **Design/Implement your "edges":** How will you connect actors (nodes), relationships (edges), and movies to each other that allows efficient traversal of the graph without needlessly copying whole objects around? Do you want to have a data structure for edges or merely represent them as connections between two nodes?  Pointers and/or vector indices might come in handy…
* **Modify the given Makefile** so that it works for your files.
* **Test your graph implementation:** load the imdb_2019.tsv file, you should expect to find around 413,105 actors or nodes, 325,382 movies, and 5,874,252 directed edges. Note: if we implement our graph with directed edges, every undirected edge will be represented by two directed edges.
* Check to make sure you d**id NOT use any pre-built data structures**, like the Boost Graph Library (BGL), besides what is provided in the [C++ STL data structures](http://www.google.com/url?q=http%3A%2F%2Fwww.cplusplus.com%2Freference%2Fstl%2F&sa=D&sntz=1&usg=AFQjCNFZRl2frO480rJueOYXTNviHbYuvA).
* You may assume the input dataset and query file is formatted well, and **no illegally formatted** file will be used to test against your program.

### Write a program called pathfinder (in pathfinder.cpp) to find the shortest path from one actor to another actor through shared movies

**Implementation Checklist:**

* Implement pathfinder to work on an unweighted graph (see ./pathfinder Details below for more information)

**./pathfinder Details:**

Your program should be called like this (see detailed explanation of arguments below):

`./pathfinder imdb_2019.tsv u test_pairs.tsv out_paths_unweighted.tsv`

where `test_pairs.tsv` contains:

``` txt
Actor1/Actress1<TAB>Actor2/Actress2
Robert Downey Jr.<TAB>Chris Evans
Amy Adams<TAB>Nicole Kidman
Will Smith<TAB>Bruce Willis
James McAvoy<TAB>Michael Fassbender
Djimon Hounsou<TAB>50 Cent

```

and your program produces an output file out_paths_unweighted.tsv containing the following (See the expected formatting details of the output file below):

``` txt
(actor)--[movie#@year]-->(actor)--...
(Robert Downey Jr.)--[Avengers: Age of Ultron#@2015]-->(Chris Evans)
(Amy Adams)--[Leap Year#@2010]-->(Matthew Goode)--[Stoker#@2013]-->(Nicole Kidman)
(Will Smith)--[Concussion#@2015]-->(Alec Baldwin)--[Mercury Rising#@1998]-->(Bruce Willis)
(James McAvoy)--[X-Men: First Class#@2011]-->(Michael Fassbender)
(Djimon Hounsou)--[Amistad#@1997]-->(Morgan Freeman)--[London Has Fallen#@2016]-->(Gerard Butler)--[Den of Thieves#@2018]-->(50 Cent)

```

`./pathfinder` will take 4 command-line arguments:

1. Name of text file containing the tab-delimited movie casts (such as imdb_2019.tsv).
2. Lower-case character u or w
    1. u -- builds the graph with unweighted edges
    2. w -- builds the graph with weighted edges (you should implement unweighted part first)
3. Name of text file containing the pairs of actors to find paths, where first line in the file is a header, and each row contains the names of the two actors separated by a single tab character
4. Name of output text file. Pathfinder will create a new file to store the results from finding the shortest path between two actors
5. The output text file should follow this **exact format** detailed here. First line of the file is a header, and each row contains the paths for the corresponding pair of actors and input pairs file (in the same order).  Each path should be formatted as follows: `(<actor name>)--[<movie title>#@<movie year>]-->(<actor name>)--[<movie title>#@<movie year>]-->(<actor name>)`....etc where the movie listed between each pair of actors is one where they both had a role.

**Notes:**

1. The specific path your pathfinder program outputs may be different than from reference solution. But the **total path weights** must be the same.
2. You may ONLY use C++ STL data structures and NOT the Boost Graph Library (BGL).
3. We will not test you on the shortest path between an actor/actress and himself or herself, feel free to handle this case at your will.

## Part B: Pathfinder on Weighted Graph (Dijkstra)

### 1. Complete your pathfinder program by implementing the "weighted edges" version of your program, where the edge weight is the age of the movie

(This is because we will want to choose newer movies over older movies when connecting two actors).

**Implementation Checklist:**

* Make pathfinder work for weighted graphs (see below for details)
* Test against reference solution refpathfinder

If we are defining an edge between two actors that played in a movie made in year Y, then the weight of that edge will be:

`weight = 1 + (2019 - Y)`

Note that we are using **2019**, which is because the dataset only contains movies released in **2019** and earlier. **Don't accidentally use other year number!**

Example:

`./pathfinder imdb_2019.tsv w test_pairs.tsv out_paths_weighted.tsv`

should produce an output file out_paths_weighted.tsv containing the following (although the particular movies may not match, the total path weights should match your output):

``` unix
(actor)--[movie#@year]-->(actor)--...
(Robert Downey Jr.)--[Avengers: Endgame#@2019]-->(Chris Evans)
(Amy Adams)--[The Woman in the Window#@2019]-->(Anthony Mackie)--[The Banker#@2019]-->(Samuel L. Jackson)--[The Last Full Measure#@2019]-->(Sebastian Stan)--[Destroyer#@2018]-->(Nicole Kidman)
(Will Smith)--[Spies in Disguise#@2019]-->(Ben Mendelsohn)--[Captain Marvel#@2019]-->(Samuel L. Jackson)--[Glass#@2019]-->(Bruce Willis)
(James McAvoy)--[X-Men: Apocalypse#@2016]-->(Michael Fassbender)
(Djimon Hounsou)--[King Arthur: Legend of the Sword#@2017]-->(Charlie Hunnam)--[Triple Frontier#@2019]-->(Oscar Isaac)--[The Addams Family#@2019]-->(Charlize Theron)--[Long Shot#@2019]-->(O'Shea Jackson Jr.)--[Den of Thieves#@2018]-->(50 Cent)

```

***The specific path your pathfinder program outputs may be different than from reference solution. As long as the total path weights are the same, then you are fine. However, you must follow the exact format as above for your output file.***

To efficiently implement Dijkstra's algorithm for shortest path in a weighted graph, you should make use of a priority queue. You can implement your own, or use the STL C++ implementation: http://www.cplusplus.com/reference/queue/priority_queue/. Note that it does not support an update_priority operation (how can you get around that?). Think about what happens if you insert the same key twice into the heap, but with a lower priority. Which one gets popped first? When you pop a key-priority pair, how do you know if it is valid/up-to-date or not?


## Hints and Warning

#### Hints

1. Remember that a hash table is given to you as a [std::unordered_set](http://www.google.com/url?q=http%3A%2F%2Fwww.cplusplus.com%2Freference%2Funordered_set%2Funordered_set%2F&sa=D&sntz=1&usg=AFQjCNFrJGQ6jUH1gjikuNzSNz3ITIvitw) and a hash map is given to you as a [std::unordered_map](http://www.google.com/url?q=http%3A%2F%2Fwww.cplusplus.com%2Freference%2Funordered_map%2Funordered_map%2F&sa=D&sntz=1&usg=AFQjCNEFef5XWq91AE2DXpCZkTkY4rw0TQ). You may NOT use any pre-built data structures, like the Boost Graph Library (BGL), besides what is provided in the [C++ STL data structures](http://www.google.com/url?q=http%3A%2F%2Fwww.cplusplus.com%2Freference%2Fstl%2F&sa=D&sntz=1&usg=AFQjCNFZRl2frO480rJueOYXTNviHbYuvA).
2. Write your own Makefile to make compilation easier.
3. Compilation problems? Try having a target .o file for each hpp file that corresponds to a class. For example:
    1. ActorGraph.o: ActorGraph.hpp Movie.o ActorNode.o OtherClass.o
    2. Movie.o: Movie.hpp
    3. ActorNode.o: ActorNode.hpp
    4. OtherClass.o:  OtherClass.hpp

#### Warning

We are giving very specific instructions on how to format the output of your programs because our auto-grader will parse your output in these formats, **and any deviation from these exact formats will cause the autograder to take off points.** There will be no special attention given to submissions that do not output results in the correct format. Although we will still give partial credit to the correctness of your results, if you do not follow the exact formatting described here, you are at risk of losing all the points for that portion of the assignment. **NO EXCEPTIONS.**

## Extra Credit opportunity : CAPE 

We strongly encourage everyone in the class to voice your opinion on the class and the instruction team on CAPE, whether they are positive or negative. If the overall response rate of our class is above 75%, everyone will receive 1 extra point for PA4. 

## Submission instructions

You should follow similar instructions as previous PAs when submitting your code to gradescope.
You should submit:

1. **Your updated Makefile.** We should be able to compile your code by simply running `make <target>` where `<target>` is pathfinder.
2. **All .cpp/.hpp files you created.** Upload the classes you designed and implemented for this part.

**Do NOT submit any dataset.** All required datasets for grading are already available on autograder and will be passed correctly to your program. **If the autograder times out when grading and we find you upload the dataset files, you forfeit your rights to re-run the autograder for regrading.**

When you have completed all of the requirements for the final submission, you should follow these instructions to submit your code:

1. **We will use your Makefile for this assignment so be sure to upload it.** You can make modifications for additional files you write, if needed.
2. **Be sure to test your code on ieng6.** We will be grading your code on the same environment as ieng6 and there may be issues with compilers/etc if you only tested your code on your personal machine.
3. Be sure to push the final version of your code to your private Github repository. That will be the code you will submit.
4. Go to gradescope and find PA4 assignment. If you successfully submitted your PA1, PA2, & PA3 (we hope you did!) then you should not have to authorize your github account again, but if you never submitted any PAs then you will be asked to authorize your github account. After authorizing your account, choose the repo you pushed your PA4 code to and the correct branch.


You can submit as many times as you like before the deadline: Only your last submission will be counted. No late submission will be accepted.
